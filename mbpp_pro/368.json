{
  "id": 368,
  "raw_solution": "    INT_BITS = 32\n    return (n << d)|(n >> (INT_BITS - d))  \n",
  "test_code": "assert rotate_numbers([123456789, 987654321], [10, 20]) == [126419751965, 1035630617538022]\nassert rotate_numbers([0, 1, 2], [0, 32, 33]) == [0, 1, 4]\nassert rotate_numbers([2147483647, 4294967295], [32, 16]) == [2147483647, 281474976710655]",
  "raw_problem": "# Write a function to that rotate left bits by d bits a given number. We assume that the number is 32 bit.\ndef left_rotate(n,d):\n",
  "new_solution": "    rotated_numbers = []\n    for num, rot in zip(numbers, rotations):\n        rot = rot % 32\n        rotated_numbers.append(left_rotate(num, rot))\n    return rotated_numbers\n",
  "new_problem": "# Given a list of 32-bit numbers and a list of corresponding rotation values, write a function to rotate each number left by its corresponding rotation value and return the list of rotated numbers. If the rotation value is greater than 32, it should be reduced modulo 32 before performing the rotation.\ndef rotate_numbers(numbers, rotations):\n"
}
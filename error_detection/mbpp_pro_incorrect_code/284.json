{
  "id": 284,
  "original_file": "mbpp_pro/284.json",
  "generation_timestamp": "2025-12-02T03:05:17.083310Z",
  "model_used": "claude-sonnet-4-5-20250929",
  "error_type": "algorithm_error",
  "generation_artifacts": {
    "prompt": "Generate incorrect versions of the following Python code that contain use a fundamentally different (and incorrect) algorithmic approach.\n\n**Original Problem Descriptions:**\n\nRaw Problem:\n# Write a function to move all the numbers to the end of the given string.\ndef move_num(test_str):\n\n\nNew Problem:\n# Given a list of strings, write a function to move all the numbers to the end of each string in the list and then concatenate all the modified strings into a single string.\ndef move_num_list(str_list):\n\n\n**Original Correct Code:**\n\nRaw Solution:\n```python\nnum_str = ''.join(i for i in test_str if i.isdigit())\n  else_str = ''.join(i for i in test_str if not i.isdigit())\n  return else_str + num_str\n```\n\nNew Solution:\n```python\ndef move_num(test_str):\n    num_str = ''.join(i for i in test_str if i.isdigit())\n    else_str = ''.join(i for i in test_str if not i.isdigit())\n    return else_str + num_str\n  return ''.join(move_num(s) for s in str_list)\n```\n\n**Your Task:**\n\nCreate incorrect versions of both solutions that contain use a fundamentally different (and incorrect) algorithmic approach. The bugs should:\n1. Be realistic and non-trivial\n2. Maintain valid Python syntax\n3. Preserve the function structure and signature\n4. Fail on some test cases while potentially passing others\n5. Be subtle enough to require careful code review to identify\n\nRespond with a JSON object containing:\n{\n  \"raw_solution_incorrect\": \"the incorrect version of raw_solution code\",\n  \"new_solution_incorrect\": \"the incorrect version of new_solution code\",\n  \"error_type\": \"algorithm_error\",\n  \"error_description\": \"a brief description of the specific error introduced\",\n  \"where_error_is\": \"where in the code the error occurs (function name, line description)\",\n  \"expected_failure_cases\": \"description of test cases or inputs where this error would cause failures\"\n}\n\nInclude ONLY the JSON object, no markdown formatting or explanations.",
    "raw_response_text": "```json\n{\n  \"raw_solution_incorrect\": \"def move_num(test_str):\\n    result = []\\n    for i in test_str:\\n        if i.isdigit():\\n            result.append(i)\\n        else:\\n            result.insert(0, i)\\n    return ''.join(result)\",\n  \"new_solution_incorrect\": \"def move_num_list(str_list):\\n    def move_num(test_str):\\n        result = []\\n        for i in test_str:\\n            if i.isdigit():\\n                result.append(i)\\n            else:\\n                result.insert(0, i)\\n        return ''.join(result)\\n    return ''.join(move_num(s) for s in str_list)\",\n  \"error_type\": \"algorithm_error\",\n  \"error_description\": \"Uses insert(0, i) to prepend non-digit characters, which reverses the order of non-digit characters. This approach builds the string by inserting non-digits at the beginning of the list, causing them to appear in reverse order compared to their original sequence.\",\n  \"where_error_is\": \"move_num function, specifically in the loop where result.insert(0, i) is used for non-digit characters\",\n  \"expected_failure_cases\": \"Any string with multiple non-digit characters will fail. For example, 'abc123' should return 'abc123' but will return 'cba123'. Similarly, 'h3e2l1lo' should return 'hello321' but will return 'olleh321'. The digits will be in correct order but all non-digit characters will be reversed.\"\n}\n```"
  },
  "original": {
    "raw_problem": "# Write a function to move all the numbers to the end of the given string.\ndef move_num(test_str):\n",
    "raw_solution": "  num_str = ''.join(i for i in test_str if i.isdigit())\n  else_str = ''.join(i for i in test_str if not i.isdigit())\n  return else_str + num_str\n",
    "new_problem": "# Given a list of strings, write a function to move all the numbers to the end of each string in the list and then concatenate all the modified strings into a single string.\ndef move_num_list(str_list):\n",
    "new_solution": "  def move_num(test_str):\n    num_str = ''.join(i for i in test_str if i.isdigit())\n    else_str = ''.join(i for i in test_str if not i.isdigit())\n    return else_str + num_str\n  return ''.join(move_num(s) for s in str_list)\n",
    "test_code": "assert move_num_list(['abc123', 'def456']) == 'abc123def456'\nassert move_num_list(['hello', 'world987']) == 'helloworld987'\nassert move_num_list(['123', '456']) == '123456'\nassert move_num_list(['a1b2c3', 'd4e5f6']) == 'abc123def456'"
  },
  "incorrect": {
    "raw_solution_incorrect": "def move_num(test_str):\n    result = []\n    for i in test_str:\n        if i.isdigit():\n            result.append(i)\n        else:\n            result.insert(0, i)\n    return ''.join(result)",
    "new_solution_incorrect": "def move_num_list(str_list):\n    def move_num(test_str):\n        result = []\n        for i in test_str:\n            if i.isdigit():\n                result.append(i)\n            else:\n                result.insert(0, i)\n        return ''.join(result)\n    return ''.join(move_num(s) for s in str_list)"
  },
  "error_metadata": {
    "error_type": "algorithm_error",
    "error_description": "Uses insert(0, i) to prepend non-digit characters, which reverses the order of non-digit characters. This approach builds the string by inserting non-digits at the beginning of the list, causing them to appear in reverse order compared to their original sequence.",
    "where_error_is": "move_num function, specifically in the loop where result.insert(0, i) is used for non-digit characters",
    "expected_failure_cases": "Any string with multiple non-digit characters will fail. For example, 'abc123' should return 'abc123' but will return 'cba123'. Similarly, 'h3e2l1lo' should return 'hello321' but will return 'olleh321'. The digits will be in correct order but all non-digit characters will be reversed."
  },
  "validation": {
    "skipped": false,
    "passed": false,
    "failure_type": "AssertionError",
    "failure_message": ""
  }
}
{
  "id": 153,
  "raw_solution": "    # consider use merge sort, but for simplicity, use brute force\n    z9q_8x = 0\n    for w3_m in range(len(k7r_2p)): \n        for b5_t in range(w3_m + 1, len(k7r_2p)): \n            if (k7r_2p[w3_m] > k7r_2p[b5_t]): \n                z9q_8x += 1\n    return z9q_8x \n",
  "test_code": "assert total_inversions([[1, 2, 3], [3, 2, 1], [1, 3, 2]]) == 4\nassert total_inversions([[1, 2, 3, 4], [4, 3, 2, 1]]) == 6\nassert total_inversions([[1, 1, 1], [2, 2, 2]]) == 0\nassert total_inversions([[5, 4, 3, 2, 1], [1, 2, 3, 4, 5]]) == 10",
  "raw_problem": "# Write a python function to count inversions in an array.\ndef get_Inv_Count(arr):\n",
  "new_solution": "    f4_q8_xz = 0\n    for k7r_2p in u2_v9s:\n        f4_q8_xz += n6_h3_Lp_Qr2(k7r_2p)\n    return f4_q8_xz\n",
  "new_problem": "# Given a list of arrays, write a Python function to find the total number of inversions across all arrays. An inversion in an array is defined as a pair (arr[i], arr[j]) where i < j and arr[i] > arr[j].\ndef total_inversions(arrays):\n"
}

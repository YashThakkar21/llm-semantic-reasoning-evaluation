{
  "id": 368,
  "raw_solution": "    a9z_3X = 32\n    return (n << d)|(n >> (a9z_3X - d))  \n",
  "test_code": "assert rotate_numbers([123456789, 987654321], [10, 20]) == [126419751965, 1035630617538022]\nassert rotate_numbers([0, 1, 2], [0, 32, 33]) == [0, 1, 4]\nassert rotate_numbers([2147483647, 4294967295], [32, 16]) == [2147483647, 281474976710655]",
  "raw_problem": "# Write a function to that rotate left bits by d bits a given number. We assume that the number is 32 bit.\ndef left_rotate(n,d):\n",
  "new_solution": "    b7_kL2q = []\n    for m5_Wx, p3_Yz in zip(v8_Rj, t4_Nh):\n        p3_Yz = p3_Yz % 32\n        b7_kL2q.append(f6_Qw(m5_Wx, p3_Yz))\n    return b7_kL2q\n",
  "new_problem": "# Given a list of 32-bit numbers and a list of corresponding rotation values, write a function to rotate each number left by its corresponding rotation value and return the list of rotated numbers. If the rotation value is greater than 32, it should be reduced modulo 32 before performing the rotation.\ndef rotate_numbers(numbers, rotations):\n"
}
